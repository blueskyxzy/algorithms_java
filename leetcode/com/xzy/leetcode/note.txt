题型归类
最经典的sliding window模式，Two pointers模式，快慢指针模式，合并intervals模式，cyclic sort模式，in-place翻转链表模式，
树上的BFS，树上的DFS，双Heaps模式，subsets模式，二分法变种，Top K模式，多路模式（K-ways），0/1背包，拓扑排序
https://zhuanlan.zhihu.com/p/341176507

基础技巧：分治、二分、贪心
排序算法：快速排序、归并排序、计数排序
搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等
图论：最短路径、最小生成树
动态规划：背包问题、最长子序列
数据结构，主要有如下几种：

数组与链表：单 / 双向链表
栈与队列
哈希表
堆：最大堆 ／ 最小堆
树与图：最近公共祖先、并查集
字符串：前缀树（字典树） ／ 后缀树

Pattern: Sliding window，滑动窗口类型
输入是一些线性结构：比如链表呀，数组啊，字符串啊之类的
让你去求最长/最短子字符串或是某些特定的长度要求


Pattern: two points, 双指针类型
双指针能帮助我们找到空间或是时间复杂度更低的解。
一般来说，数组或是链表是排好序的，你得在里头找一些组合满足某种限制条件
这种组合可能是一对数，三个数，或是一个子数组

Pattern: Fast & Slow pointers, 快慢指针类型
环上的问题，比如环形链表和环形数组
当你需要知道链表的长度或是某个特别位置的信息的时候
比如我们在单链表上不能往回移动的时候。一个典型的需要用到快慢指针的模式的是当你需要去判断一个链表是否是回文的时候。

Pattern: Merge Intervals，区间合并类型
通常咱们需要要么判断是否有重叠，要么合并区间
当你需要产生一堆相互之间没有交集的区间的时候
当你听到重叠区间的时候

Pattern: Cyclic Sort，循环排序
可以用来处理数组中的数值限定在一定的区间的问题
一般设计到排序好的数组，而且数值一般满足于一定的区间
如果问题让你需要在排好序/翻转过的数组中，寻找丢失的/重复的/最小的元素

Pattern: In-place Reversal of a LinkedList，链表翻转
要求都是你得原地翻转，就是重复使用这些已经建好的节点，而不使用额外的空间
一般需要用到多个变量，一个变量指向头结点（下图中的current），另外一个（previous）则指向咱们刚刚处理完的那个节点。在这种固定步长的方式下，你需要先将当前节点（current）指向前一个节点（previous），再移动到下一个。同时，你需要将previous总是更新到你刚刚新鲜处理完的节点，以保证正确性

Tree Breadth First Search，树上的BFS
这种模式基于宽搜（Breadth First Search (BFS)），适用于需要遍历一颗树
BFS模式是通过把根节点加到队列中，然后不断遍历直到队列为空。每一次循环中，我们都会把队头结点拿出来（remove），然后对其进行必要的操作。在删除每个节点的同时，其孩子节点，都会被加到队列中

Pattern: Tree Depth First Search，树上的DFS
树形DFS基于深搜（Depth First Search (DFS)）技术来实现树的遍历。
可以用递归（或是显示栈，如果你想用迭代方式的话）来记录遍历过程中访问过的父节点
你需要按前中后序的DFS方式遍历树
如果该问题的解一般离叶子节点比较近

Pattern: Two Heaps，双堆类型
这种模式在优先队列，计划安排问题（Scheduling）中有奇效
如果问题让你找一组数中的最大/最小/中位数
有时候，这种模式在涉及到二叉树数据结构时也特别有用

Pattern: Subsets (backtracking)，子集类型，一般都是使用多重DFS，一般用回溯来解
子集问题模式讲的是用BFS来处理这些问题。
问题需要咱们去找数字的组合或是排列

Pattern: Modified Binary Search，改造过的二分
当你需要解决的问题的输入是排好序的数组，链表，或是排好序的矩阵，要求咱们寻找某些特定元素。这个时候的不二选择就是二分搜索。这种模式是一种超级牛的用二分来解决问题的方式
对于一组满足上升排列的数集来说，这种模式的步骤是这样的：
首先，算出左右端点的中点。最简单的方式是这样的：middle = (start + end) / 2。但这种计算方式有不小的概率会出现整数越界。因此一般都推荐另外这种写法：middle = start + (end — start) / 2
如果要找的目标改好和中点所在的数值相等，我们返回中点的下标就行
如果目标不等的话：我们就有两种移动方式了
如果目标比中点在的值小（key < arr[middle]）：将下一步搜索空间放到左边（end = middle - 1）
如果比中点的值大，则继续在右边搜索，丢弃左边：left = middle + 1

Pattern: Top ‘K’ Elements，前K个系列
求解最大/最小/最频繁的K个元素的题，都遵循这种模式
用来记录这种前K类型的最佳数据结构就是堆了（译者注：在Java中，改了个名，叫优先队列（PriorityQueue））

根据题目要求，将K个元素插入到最小堆或是最大堆。
遍历剩下的还没访问的元素，如果当前出来到的这个元素比堆顶元素大，那咱们把堆顶元素先删除，再加当前元素进去。
不需要去排序数组，因为堆具有这种良好的局部有序性

识别最大K个元素模式：
如果你需要求最大/最小/最频繁的前K个元素
如果你需要通过排序去找一个特定的数

Pattern: K-way merge，多路归并
K路归并能帮咱们解决那些涉及到多组排好序的数组的问题
每当你的输入是K个排好序的数组，你就可以用堆来高效顺序遍历其中所有数组的所有元素。你可以将每个数组中最小的一个元素加入到最小堆中，从而得到全局最小值。当我们拿到这个全局最小值之后，再从该元素所在的数组里取出其后面紧挨着的元素，加入堆。如此往复直到处理完所有的元素。

该模式是这样的运行的：

把每个数组中的第一个元素都加入最小堆中
取出堆顶元素（全局最小），将该元素放入排好序的结果集合里面
将刚取出的元素所在的数组里面的下一个元素加入堆
重复步骤2，3，直到处理完所有数字

识别K路归并：

该问题的输入是排好序的数组，链表或是矩阵
如果问题让咱们合并多个排好序的集合，或是需要找这些集合中最小的元素

Pattern: 0/1 Knapsack (Dynamic Programming)，0/1背包类型

Pattern: Topological Sort (Graph)，拓扑排序类型
拓扑排序模式用来寻找一种线性的顺序，这些元素之间具有依懒性。比如，如果事件B依赖于事件A，那A在拓扑排序顺序中排在B的前面。

初始化
a) 借助于HashMap将图保存成邻接表形式。
b) 找到所有的起点，用HashMap来帮助记录每个节点的入度
创建图，找到每个节点的入度
a) 利用输入，把图建好，然后遍历一下图，将入度信息记录在HashMap中
找所有的起点
a) 所有入度为0的节点，都是有效的起点，而且我们讲他们都加入到一个队列中
排序
a) 对每个起点，执行以下步骤
—i) 把它加到结果的顺序中
— ii)将其在图中的孩子节点取到
— iii)将其孩子的入度减少1
— iv)如果孩子的入度变为0，则改孩子节点成为起点，将其加入队列中
b) 重复（a）过程，直到起点队列为空。




















1、Leetcode-1047 删除字符串中的所有相邻重复项

2、剑指 Offer 53 - I. 在排序数组中查找数字 I

3、Leetcode704:二分查找

4、 Leetcode 227：基本计算器II

5、leetcode 224：基本计算器(带括号的计算)

6、Leetcode 15：三数之和：排序+双指针

7、剑指 offer 38.字符串的排列

8、Leetcode409：最长回文串

9、Leetcode 331：验证二叉树的前序序列化

10、Leetcode 705：设计哈希集合

11、Leetcode 13：罗马数字转整数：

12、Leetcode 88：合并两个有序数组

13、Leetcode 706：设计哈希映射

14、Leetcode 54 螺旋矩阵：

15、 Leetcode 14 最长公共前缀

16、Leetcode 20：有效的括号

17、Leetcode 21：合并两个有序的链表

18、Leetcode 139：单词拆分问题

19、剑指Offer 29：顺时针打印矩阵

20、LCP 11: 期望个数统计

21、Leetcode 59：螺旋矩阵II

22、Leetcode 101 ： 对称二叉树

23、Leetcode 115:不同的子序列

24、Leetcode 1603 ：设计停车系统

25、Leetcode 290：单词规律

26、Leetcode 6：Z字形变换

27、Leetcode 914：卡牌分组

28、面试题 01.08 零矩阵：

29、Leetcode 150：逆波兰表达式求值

30、Leetcode 232：用栈实现队列

31、Leetcode 503：下一个更大元素II

32、Leetcode 131：分割回文串

33、Leetcode 92：反转链表II

第二章 二叉树/N叉树

1、Leetcode 94：二叉树的中序遍历

2、Leetcode 144：二叉树的前序遍历

3、Leetcode 145：二叉树的后序遍历

4、N叉树的后续遍历

5、Leetcode 589：N叉树的前序遍历：

6、Leetcode 429：N叉树的层序遍历

第三章：哈希表

1、Leetcode 242：有效的字母异位

2、 Leetcode 49：字母异位词分组

3、Leetcode1：两数之和

第四章 递归

1、 Leetcode-70: 爬楼梯问题

2、Leetcode-22：括号生成问题

3、Leetcode 98：验证二叉搜索树

4、Leetcode226：翻转二叉树

5、Leetcode104：二叉树的最大深度

6、Leetcode111：二叉树的最小深度

7、Leetcode509：斐波那契数列

8、Leetcode 297：二叉树的序列化和反序列化

9、Leetcode236：二叉树的公共祖先

10、Leetcode 105：从前序与中序遍历序列构造二叉树

11、 Leetcode 77: permutation

12、Leetcode 46：全排列

13、Leetcode 47：全排列II

第五章 动态规划

1、Leetcode 62：不同路径

2、Leetcode 63：不同路径II

3、Leetcode 1143：最长公共子序列

4、Leetcode 70：爬楼梯

5、Leetcode 120:三角形的最小路径和

6、Leetcode 55: 最大子序和

7、Leetcode 152：乘积最大子树和

8、Leetcode 332：零钱兑换问题

9、Leetcode 198：打家劫舍

10、Leetcode 121：买卖股票的最佳时机

11、Leetcode 122：买入股票的最佳时机II

12、Leetcode 123：买卖股票的最佳时机III

13、Leetcode 309：最佳买卖股票时机含冷冻期

14、Leetcode 188:买卖股票的最佳时机IV

15、Leetcode 714：买卖股票的最佳时机含手续费

16、Leetcode 32：最长有效括号

17、Leetcode 64：最小路径和

18、Leetcode 72 ：编辑距离

19、Leetcode 91：解码方法

20、Leetcode 221：最大正方形

21、Leetcode 403：青蛙过河

22、Leetcode 410：分割数组的最大值

23、Leetcode 552：学生出勤记录II

24、Leetcode 647：回文子串

25、Leetcode 76：最小覆盖子串

26、Leetcode 312：戳气球

27、Leetcode 213：打家劫舍ii

28、Leetcode 300:最长递增子序列

29、Leetcode 53:最大子序列和

30、Leetcode 72：编辑距离计算

31、Leetcode 332：零钱兑换

32、Leetcode 494：目标和

总结

第六章 分治、回溯

分治代码模板

回溯

1、Leetcode 50：Pow(x,n)

2、Leetcode 78：子集

3、Leetcode 169：多数元素

4、Leetcode 17：电话号码的字母组合

5、Leetcode 51：N皇后问题

第七章 深度优先搜索和广度优先搜索

1、Leetcode 102：二叉树的层序遍历

2、Leetcode 433：最小基因变化

3、Leetcode 22: 括号生成问题重写

4、Leetcode 515：在每个树行中找最大值

5、Leetcode 127：单词接龙

6、Leetcode 200：岛屿数量

第八章 ：贪心搜索

1、Leetcode 455：分发饼干

2、Leetcode 122：买卖股票的最佳时机 II

3、Leetcode 55：跳跃游戏

4、Leetcode 860：柠檬水找零

5、Leetcode 874: 模拟行走机器人

6、Leetcode 42: 跳跃游戏II

第九章 二分查找

1、Leetcode 69：x的平方根

2、Leetcode 33：搜索旋转排序数组

3、Leetcode 367：有效的完全平方数

4、Leetcode 74：搜索二维矩阵

5、Leetcode 153：寻找旋转排序数组中的最小值

第十章 字典树

1、Leetcode 208：实现前缀树

2、Leetcode 212：单词搜索

第十一章 并查集

1、Leetcode 200: 岛屿数量

2、Leetcode 130：被围绕的区域

第十二章 高级搜索

1、Leetcode 22 括号生成重新

2、Leetcode 51 ：N皇后重写

3、Leetcode 36：有效的数独

4、Leetcode 37：解数独

5、Leetcode 127：单词接龙重写

6、Leetcode 433：最小基因变化重新

7、Leetcode 773：滑动谜题

第十三章 红黑树和AVL树

第十四章 排序算法

1、简单的排序

冒泡排序

选择排序

插入排序

希尔排序

2、高级排序

快速排序

归并排序

3、Leetcode 1122：数组的相对排序

4、Leetcode 242：有效的字母异位词

5、Leetcode 1244：力扣排行榜

6、Leetcode 56：合并区间

7、剑指Offer 51 数组中的逆序对

8、Leetcode 491: 翻转对

第十五章 字符串相关问题

1、Leetcode 709 转换成小写字母

2、Leetcode 58：最后一个单词的长度

3、Leetcode 771：宝石与石头

4、剑指offer 50：第一个只出现一次的字符

5、Leetcode 8：字符串转换整数

6、Leetcode 14：最长公共前缀

7、Leetcode 344：反转字符串

8、Leetcode 541：反转字符串ii

9、Leetcode 151：反转字符串里的单词

10、Leetcode 557：反转字符串中的单词III

11、Leetcode 917：仅仅反转字母

12、Leetcode 242：有效的字母异位词重写

13、Leetcode 49：字母异位词分组：

14、Leetcode 438：找到字符串中的所有字母异位词

15、Leetcode 1143：最长公共子序列重写

16、Leetcode 125：验证回文串

17、Leetcode 680：验证回文字符串ii

18、Leetcode 5：最长回文子串

19、Leetcode 72：编辑距离重写

20、Leetcode 10：正则表达式匹配

21、Leetcode 44：通配符匹配

22、Leetcode 115：不同的子序列重写

23、Leetcode 387：字符串中的第一个唯一字符

24、Leetcode 8：字符串转换整数重写

25、Leetcode 541：反转字符串II重写

26、Leetcode 151：翻转字符串里的单词重写

27、Leetcode 537：反转字符串中的单词iii重写

28、Leetcode 917：仅反转字母重写

29、Leetcode 438：找到字符串中所有字母异位词重写

30、Leetcode 5：最长回文串重写

31、Leetcode 205：同构字符串

32、Leetcode 680：验证回文字符串II重写

33、Leetcode 44：通配符匹配重写

34、Leetcode 32：最长有效括号重写

35、Leetcode 115：不同的子序列重写

第十六章 高级动态规划

1、Leetcode 300：最长递增子序列重做

2、Leetcode 91：解码方法重做

3、Leetcode 32：最长有效括号重写

4、Leetcode 85：最大矩形

5、Leetcode 115：不同的子序列重写

6、Leetcode 818:赛车

第十七章 布隆过滤器&LRU cache

Leetcode 146:LRU缓存机制

第十八章 位运算

1、Leetcode 191：位1的个数

2、Leetcode 231:2的幂

3、 Leetcode 190:颠倒二进制位

4、Leetcode 51：N皇后问题的位运算解法

5、Leetcode 52：N皇后ii

6、Leetcode 338：比特位计数