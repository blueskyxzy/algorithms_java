题型归类
最经典的sliding window模式，Two pointers模式，快慢指针模式，合并intervals模式，cyclic sort模式，in-place翻转链表模式，
树上的BFS，树上的DFS，双Heaps模式，subsets模式，二分法变种，Top K模式，多路模式（K-ways），0/1背包，拓扑排序
https://zhuanlan.zhihu.com/p/341176507

基础技巧：分治、二分、贪心
排序算法：快速排序、归并排序、计数排序
搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等
图论：最短路径、最小生成树
动态规划：背包问题、最长子序列
数据结构，主要有如下几种：

数组与链表：单 / 双向链表
栈与队列
哈希表
堆：最大堆 ／ 最小堆
树与图：最近公共祖先、并查集
字符串：前缀树（字典树） ／ 后缀树

Pattern: Sliding window，滑动窗口类型
输入是一些线性结构：比如链表呀，数组啊，字符串啊之类的
让你去求最长/最短子字符串或是某些特定的长度要求


Pattern: two points, 双指针类型
双指针能帮助我们找到空间或是时间复杂度更低的解。
一般来说，数组或是链表是排好序的，你得在里头找一些组合满足某种限制条件
这种组合可能是一对数，三个数，或是一个子数组

Pattern: Fast & Slow pointers, 快慢指针类型
环上的问题，比如环形链表和环形数组
当你需要知道链表的长度或是某个特别位置的信息的时候
比如我们在单链表上不能往回移动的时候。一个典型的需要用到快慢指针的模式的是当你需要去判断一个链表是否是回文的时候。

Pattern: Merge Intervals，区间合并类型
通常咱们需要要么判断是否有重叠，要么合并区间
当你需要产生一堆相互之间没有交集的区间的时候
当你听到重叠区间的时候

Pattern: Cyclic Sort，循环排序
可以用来处理数组中的数值限定在一定的区间的问题
一般设计到排序好的数组，而且数值一般满足于一定的区间
如果问题让你需要在排好序/翻转过的数组中，寻找丢失的/重复的/最小的元素

Pattern: In-place Reversal of a LinkedList，链表翻转
要求都是你得原地翻转，就是重复使用这些已经建好的节点，而不使用额外的空间
一般需要用到多个变量，一个变量指向头结点（下图中的current），另外一个（previous）则指向咱们刚刚处理完的那个节点。在这种固定步长的方式下，你需要先将当前节点（current）指向前一个节点（previous），再移动到下一个。同时，你需要将previous总是更新到你刚刚新鲜处理完的节点，以保证正确性

Tree Breadth First Search，树上的BFS
这种模式基于宽搜（Breadth First Search (BFS)），适用于需要遍历一颗树
BFS模式是通过把根节点加到队列中，然后不断遍历直到队列为空。每一次循环中，我们都会把队头结点拿出来（remove），然后对其进行必要的操作。在删除每个节点的同时，其孩子节点，都会被加到队列中

Pattern: Tree Depth First Search，树上的DFS
树形DFS基于深搜（Depth First Search (DFS)）技术来实现树的遍历。
可以用递归（或是显示栈，如果你想用迭代方式的话）来记录遍历过程中访问过的父节点
你需要按前中后序的DFS方式遍历树
如果该问题的解一般离叶子节点比较近

Pattern: Two Heaps，双堆类型
这种模式在优先队列，计划安排问题（Scheduling）中有奇效
如果问题让你找一组数中的最大/最小/中位数
有时候，这种模式在涉及到二叉树数据结构时也特别有用

Pattern: Subsets (backtracking)，子集类型，一般都是使用多重DFS，一般用回溯来解
子集问题模式讲的是用BFS来处理这些问题。
问题需要咱们去找数字的组合或是排列

Pattern: Modified Binary Search，改造过的二分
当你需要解决的问题的输入是排好序的数组，链表，或是排好序的矩阵，要求咱们寻找某些特定元素。这个时候的不二选择就是二分搜索。这种模式是一种超级牛的用二分来解决问题的方式
对于一组满足上升排列的数集来说，这种模式的步骤是这样的：
首先，算出左右端点的中点。最简单的方式是这样的：middle = (start + end) / 2。但这种计算方式有不小的概率会出现整数越界。因此一般都推荐另外这种写法：middle = start + (end — start) / 2
如果要找的目标改好和中点所在的数值相等，我们返回中点的下标就行
如果目标不等的话：我们就有两种移动方式了
如果目标比中点在的值小（key < arr[middle]）：将下一步搜索空间放到左边（end = middle - 1）
如果比中点的值大，则继续在右边搜索，丢弃左边：left = middle + 1

Pattern: Top ‘K’ Elements，前K个系列
求解最大/最小/最频繁的K个元素的题，都遵循这种模式
用来记录这种前K类型的最佳数据结构就是堆了（译者注：在Java中，改了个名，叫优先队列（PriorityQueue））

根据题目要求，将K个元素插入到最小堆或是最大堆。
遍历剩下的还没访问的元素，如果当前出来到的这个元素比堆顶元素大，那咱们把堆顶元素先删除，再加当前元素进去。
不需要去排序数组，因为堆具有这种良好的局部有序性

识别最大K个元素模式：
如果你需要求最大/最小/最频繁的前K个元素
如果你需要通过排序去找一个特定的数

Pattern: K-way merge，多路归并
K路归并能帮咱们解决那些涉及到多组排好序的数组的问题
每当你的输入是K个排好序的数组，你就可以用堆来高效顺序遍历其中所有数组的所有元素。你可以将每个数组中最小的一个元素加入到最小堆中，从而得到全局最小值。当我们拿到这个全局最小值之后，再从该元素所在的数组里取出其后面紧挨着的元素，加入堆。如此往复直到处理完所有的元素。

该模式是这样的运行的：

把每个数组中的第一个元素都加入最小堆中
取出堆顶元素（全局最小），将该元素放入排好序的结果集合里面
将刚取出的元素所在的数组里面的下一个元素加入堆
重复步骤2，3，直到处理完所有数字

识别K路归并：

该问题的输入是排好序的数组，链表或是矩阵
如果问题让咱们合并多个排好序的集合，或是需要找这些集合中最小的元素

Pattern: 0/1 Knapsack (Dynamic Programming)，0/1背包类型

Pattern: Topological Sort (Graph)，拓扑排序类型
拓扑排序模式用来寻找一种线性的顺序，这些元素之间具有依懒性。比如，如果事件B依赖于事件A，那A在拓扑排序顺序中排在B的前面。

初始化
a) 借助于HashMap将图保存成邻接表形式。
b) 找到所有的起点，用HashMap来帮助记录每个节点的入度
创建图，找到每个节点的入度
a) 利用输入，把图建好，然后遍历一下图，将入度信息记录在HashMap中
找所有的起点
a) 所有入度为0的节点，都是有效的起点，而且我们讲他们都加入到一个队列中
排序
a) 对每个起点，执行以下步骤
—i) 把它加到结果的顺序中
— ii)将其在图中的孩子节点取到
— iii)将其孩子的入度减少1
— iv)如果孩子的入度变为0，则改孩子节点成为起点，将其加入队列中
b) 重复（a）过程，直到起点队列为空。

