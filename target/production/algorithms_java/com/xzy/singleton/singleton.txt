单例模式

一个类只有一个实例对象，并提供一个访问该实例的全局访问点

不能new 对象了，通过get方法中获取唯一实例（私有化变量，静态内部类的变量）（除了枚举）

应用场景：
1.Windows的 任务管理器
2.Windows的回收站
3.读取配置文件的类
4.网站的计数器，以便同步
5.数据库连接池
6.操作系统的文件系统
7.servlet的Application
8.Spring中的每个bean.优点方便Spring容器管理
9.servlet的每个Servlet
10.Spring MVC/struts1中的控制器对象


优点：只有一个实例，内存占用和系统开销少。一个对象消耗较多资源可以用这个来永久驻留内存并且保证数据同步
可以在系统设置全局的访问点，优化资源访问结构

5种实现方式：
1.饿汉式（线程安全，效率高，但不能延迟加载）
2.懒汉式（线程安全，效率不高，能延迟加载）
3.双重检测琐式（由于JVM底层内部模型原因，偶尔会出问题，不建议使用）
4.静态内部类式（线程安全，效率高，可以延迟加载）
5.枚举单例（线程安全，效率高，不能延迟加载）


饿汉式：
    1.私有化构造器
    2.创建自己类的对象变量，私有化 ，静态化（类装载时初始化，不涉及多线程对象访问该对象的问题）final
    3.共有的方法返回私有化本类对象

    只装载一次该类，不存在并发问题

    只加载本类，不调用返回对象的方法，则资源浪费

懒汉式：
    和饿汉式区别：1.私有化类变量不需要创建实例，在访问方法的时候再调用变量创建实例

    用的时候再创建实例，延迟加载
    类加载没有类变量实例，创建实例的方法需要加synchronized，资源利用率高（用的时候再调），效率低（同步）

双重检测锁式：
    基于懒汉式修改，同步写到if下面，第一次==null时同步

    但编译器原因偶然会出问题

静态内部类式：
    一种懒加载   （类初始化不加载静态内部类，用静态内部类的时候再加载）
    定义静态内部类里面定义类实例变量，static final
    外部类没有static变量，不会立即加载
    兼容并发高效和延迟加载

枚举式：
    枚举类本来就是单例的，JVM提供保障，可以避免反射和反序列化产生新的对象
    简单
    但是没有延迟加载功能


选用
    单例对象占资源少，不需要延迟加载：
        枚举 > 饿汉式
    单例对象占资源大，需要延迟加载
        静态内部类 > 懒汉式

反射和反序列化破解单例模式（枚举式没法破解）

